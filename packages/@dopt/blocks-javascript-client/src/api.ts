/* tslint:disable */
/* eslint-disable */
/**
 * Switchboard Blocks API
 * The Switchboard Blocks API
 *
 * The version of the OpenAPI document: 0.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BadRequestErrorResponseBody
 */
export interface BadRequestErrorResponseBody {
    /**
     * 
     * @type {BadRequestErrorResponseBodyCode}
     * @memberof BadRequestErrorResponseBody
     */
    'code': BadRequestErrorResponseBodyCode;
    /**
     * 
     * @type {string}
     * @memberof BadRequestErrorResponseBody
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface BadRequestErrorResponseBodyCode
 */
export interface BadRequestErrorResponseBodyCode {
}
/**
 * 
 * @export
 * @interface BlockIntent
 */
export interface BlockIntent {
}
/**
 * 
 * @export
 * @interface BlockIntentRequestParams
 */
export interface BlockIntentRequestParams {
    /**
     * 
     * @type {string}
     * @memberof BlockIntentRequestParams
     */
    'uid': string;
    /**
     * 
     * @type {BlockIntent}
     * @memberof BlockIntentRequestParams
     */
    'intent': BlockIntent;
}
/**
 * 
 * @export
 * @interface BlockQueryString
 */
export interface BlockQueryString {
    /**
     * 
     * @type {number}
     * @memberof BlockQueryString
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof BlockQueryString
     */
    'userIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof BlockQueryString
     */
    'groupIdentifier'?: string;
}
/**
 * 
 * @export
 * @interface BlockRequestParams
 */
export interface BlockRequestParams {
    /**
     * 
     * @type {string}
     * @memberof BlockRequestParams
     */
    'uid': string;
    /**
     * 
     * @type {BlockIntent}
     * @memberof BlockRequestParams
     */
    'intent'?: BlockIntent;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CompleteIntent = {
    Complete: 'complete'
} as const;

export type CompleteIntent = typeof CompleteIntent[keyof typeof CompleteIntent];


/**
 * 
 * @export
 * @enum {string}
 */

export const ExitIntent = {
    Exit: 'exit'
} as const;

export type ExitIntent = typeof ExitIntent[keyof typeof ExitIntent];


/**
 * 
 * @export
 * @interface FlowIntent
 */
export interface FlowIntent {
}
/**
 * 
 * @export
 * @interface FlowIntentIntentParameter
 */
export interface FlowIntentIntentParameter {
}
/**
 * 
 * @export
 * @interface FlowIntentRequestParams
 */
export interface FlowIntentRequestParams {
    /**
     * 
     * @type {string}
     * @memberof FlowIntentRequestParams
     */
    'uid': string;
    /**
     * 
     * @type {FlowIntentIntentParameter}
     * @memberof FlowIntentRequestParams
     */
    'intent'?: FlowIntentIntentParameter;
}
/**
 * 
 * @export
 * @interface FlowQueryString
 */
export interface FlowQueryString {
    /**
     * 
     * @type {number}
     * @memberof FlowQueryString
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof FlowQueryString
     */
    'userIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof FlowQueryString
     */
    'groupIdentifier'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FlowQueryString
     */
    'include[block]'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FlowQueryString
     */
    'include[block][journey]'?: boolean;
}
/**
 * 
 * @export
 * @interface FlowRequestParams
 */
export interface FlowRequestParams {
    /**
     * 
     * @type {string}
     * @memberof FlowRequestParams
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof FlowRequestParams
     */
    'intent'?: string;
}
/**
 * 
 * @export
 * @interface FlowResponseBody
 */
export interface FlowResponseBody {
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBody
     */
    'kind': FlowResponseBodyKindEnum;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBody
     */
    'type': FlowResponseBodyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBody
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBody
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof FlowResponseBody
     */
    'version': number;
    /**
     * 
     * @type {FlowResponseBodyState}
     * @memberof FlowResponseBody
     */
    'state': FlowResponseBodyState;
    /**
     * 
     * @type {Array<FlowResponseBodyBlocksInner>}
     * @memberof FlowResponseBody
     */
    'blocks'?: Array<FlowResponseBodyBlocksInner>;
}

export const FlowResponseBodyKindEnum = {
    Flow: 'flow'
} as const;

export type FlowResponseBodyKindEnum = typeof FlowResponseBodyKindEnum[keyof typeof FlowResponseBodyKindEnum];
export const FlowResponseBodyTypeEnum = {
    Flow: 'flow'
} as const;

export type FlowResponseBodyTypeEnum = typeof FlowResponseBodyTypeEnum[keyof typeof FlowResponseBodyTypeEnum];

/**
 * 
 * @export
 * @interface FlowResponseBodyBlocksInner
 */
export interface FlowResponseBodyBlocksInner {
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBodyBlocksInner
     */
    'kind': FlowResponseBodyBlocksInnerKindEnum;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBodyBlocksInner
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBodyBlocksInner
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof FlowResponseBodyBlocksInner
     */
    'version': number;
    /**
     * 
     * @type {GroupState}
     * @memberof FlowResponseBodyBlocksInner
     */
    'state': GroupState;
    /**
     * 
     * @type {string}
     * @memberof FlowResponseBodyBlocksInner
     */
    'type': FlowResponseBodyBlocksInnerTypeEnum;
    /**
     * 
     * @type {Array<ModelFieldsInner>}
     * @memberof FlowResponseBodyBlocksInner
     */
    'fields': Array<ModelFieldsInner>;
    /**
     * 
     * @type {number}
     * @memberof FlowResponseBodyBlocksInner
     */
    'size': number;
    /**
     * 
     * @type {Array<Model>}
     * @memberof FlowResponseBodyBlocksInner
     */
    'blocks': Array<Model>;
    /**
     * 
     * @type {boolean}
     * @memberof FlowResponseBodyBlocksInner
     */
    'ordered'?: boolean;
}

export const FlowResponseBodyBlocksInnerKindEnum = {
    Block: 'block'
} as const;

export type FlowResponseBodyBlocksInnerKindEnum = typeof FlowResponseBodyBlocksInnerKindEnum[keyof typeof FlowResponseBodyBlocksInnerKindEnum];
export const FlowResponseBodyBlocksInnerTypeEnum = {
    Set: 'set'
} as const;

export type FlowResponseBodyBlocksInnerTypeEnum = typeof FlowResponseBodyBlocksInnerTypeEnum[keyof typeof FlowResponseBodyBlocksInnerTypeEnum];

/**
 * 
 * @export
 * @interface FlowResponseBodyState
 */
export interface FlowResponseBodyState {
    /**
     * 
     * @type {boolean}
     * @memberof FlowResponseBodyState
     */
    'exited': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FlowResponseBodyState
     */
    'started': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FlowResponseBodyState
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GoToIntent = {
    GoTo: 'goTo'
} as const;

export type GoToIntent = typeof GoToIntent[keyof typeof GoToIntent];


/**
 * 
 * @export
 * @interface GoToQueryString
 */
export interface GoToQueryString {
    /**
     * 
     * @type {number}
     * @memberof GoToQueryString
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof GoToQueryString
     */
    'userIdentifier': string;
    /**
     * 
     * @type {string}
     * @memberof GoToQueryString
     */
    'groupIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof GoToQueryString
     */
    'blockUid': string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'kind': GroupKindEnum;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'version': number;
    /**
     * 
     * @type {GroupState}
     * @memberof Group
     */
    'state': GroupState;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    'size': number;
    /**
     * 
     * @type {Array<Model>}
     * @memberof Group
     */
    'blocks': Array<Model>;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    'type': GroupTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Group
     */
    'ordered'?: boolean;
}

export const GroupKindEnum = {
    Block: 'block'
} as const;

export type GroupKindEnum = typeof GroupKindEnum[keyof typeof GroupKindEnum];
export const GroupTypeEnum = {
    Set: 'set'
} as const;

export type GroupTypeEnum = typeof GroupTypeEnum[keyof typeof GroupTypeEnum];

/**
 * 
 * @export
 * @interface GroupState
 */
export interface GroupState {
    /**
     * 
     * @type {boolean}
     * @memberof GroupState
     */
    'active': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof GroupState
     */
    'completed': boolean;
}
/**
 * 
 * @export
 * @interface HealthCheckResponseBody
 */
export interface HealthCheckResponseBody {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResponseBody
     */
    'application': string;
    /**
     * 
     * @type {number}
     * @memberof HealthCheckResponseBody
     */
    'status': number;
}
/**
 * 
 * @export
 * @interface InternalServerErrorResponseBody
 */
export interface InternalServerErrorResponseBody {
    /**
     * 
     * @type {InternalServerErrorResponseBodyCode}
     * @memberof InternalServerErrorResponseBody
     */
    'code': InternalServerErrorResponseBodyCode;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorResponseBody
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface InternalServerErrorResponseBodyCode
 */
export interface InternalServerErrorResponseBodyCode {
}
/**
 * 
 * @export
 * @interface Model
 */
export interface Model {
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'kind': ModelKindEnum;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof Model
     */
    'version': number;
    /**
     * 
     * @type {GroupState}
     * @memberof Model
     */
    'state': GroupState;
    /**
     * 
     * @type {string}
     * @memberof Model
     */
    'type': ModelTypeEnum;
    /**
     * 
     * @type {Array<ModelFieldsInner>}
     * @memberof Model
     */
    'fields': Array<ModelFieldsInner>;
}

export const ModelKindEnum = {
    Block: 'block'
} as const;

export type ModelKindEnum = typeof ModelKindEnum[keyof typeof ModelKindEnum];
export const ModelTypeEnum = {
    Model: 'model'
} as const;

export type ModelTypeEnum = typeof ModelTypeEnum[keyof typeof ModelTypeEnum];

/**
 * 
 * @export
 * @interface ModelFieldsInner
 */
export interface ModelFieldsInner {
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInner
     */
    'sid': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInner
     */
    'type': ModelFieldsInnerTypeEnum;
    /**
     * 
     * @type {ModelFieldsInnerAnyOf2Value}
     * @memberof ModelFieldsInner
     */
    'value': ModelFieldsInnerAnyOf2Value;
}

export const ModelFieldsInnerTypeEnum = {
    Boolean: 'boolean'
} as const;

export type ModelFieldsInnerTypeEnum = typeof ModelFieldsInnerTypeEnum[keyof typeof ModelFieldsInnerTypeEnum];

/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOf
 */
export interface ModelFieldsInnerAnyOf {
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf
     */
    'sid': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf
     */
    'type': ModelFieldsInnerAnyOfTypeEnum;
    /**
     * 
     * @type {ModelFieldsInnerAnyOfValue}
     * @memberof ModelFieldsInnerAnyOf
     */
    'value': ModelFieldsInnerAnyOfValue;
}

export const ModelFieldsInnerAnyOfTypeEnum = {
    String: 'string'
} as const;

export type ModelFieldsInnerAnyOfTypeEnum = typeof ModelFieldsInnerAnyOfTypeEnum[keyof typeof ModelFieldsInnerAnyOfTypeEnum];

/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOf1
 */
export interface ModelFieldsInnerAnyOf1 {
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf1
     */
    'sid': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf1
     */
    'type': ModelFieldsInnerAnyOf1TypeEnum;
    /**
     * 
     * @type {ModelFieldsInnerAnyOf1Value}
     * @memberof ModelFieldsInnerAnyOf1
     */
    'value': ModelFieldsInnerAnyOf1Value;
}

export const ModelFieldsInnerAnyOf1TypeEnum = {
    Number: 'number'
} as const;

export type ModelFieldsInnerAnyOf1TypeEnum = typeof ModelFieldsInnerAnyOf1TypeEnum[keyof typeof ModelFieldsInnerAnyOf1TypeEnum];

/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOf1Value
 */
export interface ModelFieldsInnerAnyOf1Value {
}
/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOf2
 */
export interface ModelFieldsInnerAnyOf2 {
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf2
     */
    'sid': string;
    /**
     * 
     * @type {string}
     * @memberof ModelFieldsInnerAnyOf2
     */
    'type': ModelFieldsInnerAnyOf2TypeEnum;
    /**
     * 
     * @type {ModelFieldsInnerAnyOf2Value}
     * @memberof ModelFieldsInnerAnyOf2
     */
    'value': ModelFieldsInnerAnyOf2Value;
}

export const ModelFieldsInnerAnyOf2TypeEnum = {
    Boolean: 'boolean'
} as const;

export type ModelFieldsInnerAnyOf2TypeEnum = typeof ModelFieldsInnerAnyOf2TypeEnum[keyof typeof ModelFieldsInnerAnyOf2TypeEnum];

/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOf2Value
 */
export interface ModelFieldsInnerAnyOf2Value {
}
/**
 * 
 * @export
 * @interface ModelFieldsInnerAnyOfValue
 */
export interface ModelFieldsInnerAnyOfValue {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const NextIntent = {
    Next: 'next'
} as const;

export type NextIntent = typeof NextIntent[keyof typeof NextIntent];


/**
 * 
 * @export
 * @interface NotFoundErrorResponseBody
 */
export interface NotFoundErrorResponseBody {
    /**
     * 
     * @type {NotFoundErrorResponseBodyCode}
     * @memberof NotFoundErrorResponseBody
     */
    'code': NotFoundErrorResponseBodyCode;
    /**
     * 
     * @type {string}
     * @memberof NotFoundErrorResponseBody
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface NotFoundErrorResponseBodyCode
 */
export interface NotFoundErrorResponseBodyCode {
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PrevIntent = {
    Prev: 'prev'
} as const;

export type PrevIntent = typeof PrevIntent[keyof typeof PrevIntent];


/**
 * 
 * @export
 * @enum {string}
 */

export const ResetIntent = {
    Reset: 'reset'
} as const;

export type ResetIntent = typeof ResetIntent[keyof typeof ResetIntent];


/**
 * 
 * @export
 * @interface SerializableBlock
 */
export interface SerializableBlock {
    /**
     * 
     * @type {string}
     * @memberof SerializableBlock
     */
    'kind': SerializableBlockKindEnum;
    /**
     * 
     * @type {string}
     * @memberof SerializableBlock
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof SerializableBlock
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof SerializableBlock
     */
    'version': number;
    /**
     * 
     * @type {GroupState}
     * @memberof SerializableBlock
     */
    'state': GroupState;
    /**
     * 
     * @type {string}
     * @memberof SerializableBlock
     */
    'type': SerializableBlockTypeEnum;
    /**
     * 
     * @type {Array<ModelFieldsInner>}
     * @memberof SerializableBlock
     */
    'fields': Array<ModelFieldsInner>;
    /**
     * 
     * @type {number}
     * @memberof SerializableBlock
     */
    'size': number;
    /**
     * 
     * @type {Array<Model>}
     * @memberof SerializableBlock
     */
    'blocks': Array<Model>;
    /**
     * 
     * @type {boolean}
     * @memberof SerializableBlock
     */
    'ordered'?: boolean;
}

export const SerializableBlockKindEnum = {
    Block: 'block'
} as const;

export type SerializableBlockKindEnum = typeof SerializableBlockKindEnum[keyof typeof SerializableBlockKindEnum];
export const SerializableBlockTypeEnum = {
    Set: 'set'
} as const;

export type SerializableBlockTypeEnum = typeof SerializableBlockTypeEnum[keyof typeof SerializableBlockTypeEnum];

/**
 * 
 * @export
 * @interface SerializableFlow
 */
export interface SerializableFlow {
    /**
     * 
     * @type {string}
     * @memberof SerializableFlow
     */
    'kind': SerializableFlowKindEnum;
    /**
     * 
     * @type {string}
     * @memberof SerializableFlow
     */
    'type': SerializableFlowTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SerializableFlow
     */
    'uid': string;
    /**
     * 
     * @type {string}
     * @memberof SerializableFlow
     */
    'sid': string;
    /**
     * 
     * @type {number}
     * @memberof SerializableFlow
     */
    'version': number;
    /**
     * 
     * @type {FlowResponseBodyState}
     * @memberof SerializableFlow
     */
    'state': FlowResponseBodyState;
}

export const SerializableFlowKindEnum = {
    Flow: 'flow'
} as const;

export type SerializableFlowKindEnum = typeof SerializableFlowKindEnum[keyof typeof SerializableFlowKindEnum];
export const SerializableFlowTypeEnum = {
    Flow: 'flow'
} as const;

export type SerializableFlowTypeEnum = typeof SerializableFlowTypeEnum[keyof typeof SerializableFlowTypeEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const StartIntent = {
    Start: 'start'
} as const;

export type StartIntent = typeof StartIntent[keyof typeof StartIntent];


/**
 * 
 * @export
 * @interface TimeoutErrorResponseBody
 */
export interface TimeoutErrorResponseBody {
    /**
     * 
     * @type {InternalServerErrorResponseBodyCode}
     * @memberof TimeoutErrorResponseBody
     */
    'code': InternalServerErrorResponseBodyCode;
    /**
     * 
     * @type {string}
     * @memberof TimeoutErrorResponseBody
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface UnauthorizedErrorResponseBody
 */
export interface UnauthorizedErrorResponseBody {
    /**
     * 
     * @type {UnauthorizedErrorResponseBodyCode}
     * @memberof UnauthorizedErrorResponseBody
     */
    'code': UnauthorizedErrorResponseBodyCode;
    /**
     * 
     * @type {string}
     * @memberof UnauthorizedErrorResponseBody
     */
    'details': string;
}
/**
 * 
 * @export
 * @interface UnauthorizedErrorResponseBodyCode
 */
export interface UnauthorizedErrorResponseBodyCode {
}

/**
 * APIApi - axios parameter creator
 * @export
 */
export const APIApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} blockUid 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockGoToIntent: async (version: number, userIdentifier: string, blockUid: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('blockGoToIntent', 'version', version)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('blockGoToIntent', 'userIdentifier', userIdentifier)
            // verify required parameter 'blockUid' is not null or undefined
            assertParamExists('blockGoToIntent', 'blockUid', blockUid)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('blockGoToIntent', 'uid', uid)
            // verify required parameter 'intent' is not null or undefined
            assertParamExists('blockGoToIntent', 'intent', intent)
            const localVarPath = `/v1/block/{uid}/goTo`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"intent"}}`, encodeURIComponent(String(intent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (userIdentifier !== undefined) {
                localVarQueryParameter['userIdentifier'] = userIdentifier;
            }

            if (groupIdentifier !== undefined) {
                localVarQueryParameter['groupIdentifier'] = groupIdentifier;
            }

            if (blockUid !== undefined) {
                localVarQueryParameter['blockUid'] = blockUid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockIntent: async (version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('blockIntent', 'version', version)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('blockIntent', 'userIdentifier', userIdentifier)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('blockIntent', 'uid', uid)
            // verify required parameter 'intent' is not null or undefined
            assertParamExists('blockIntent', 'intent', intent)
            const localVarPath = `/v1/block/{uid}/{intent}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"intent"}}`, encodeURIComponent(String(intent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (userIdentifier !== undefined) {
                localVarQueryParameter['userIdentifier'] = userIdentifier;
            }

            if (groupIdentifier !== undefined) {
                localVarQueryParameter['groupIdentifier'] = groupIdentifier;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {FlowIntentIntentParameter} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowIntent: async (version: number, userIdentifier: string, uid: string, intent: FlowIntentIntentParameter, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('flowIntent', 'version', version)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('flowIntent', 'userIdentifier', userIdentifier)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('flowIntent', 'uid', uid)
            // verify required parameter 'intent' is not null or undefined
            assertParamExists('flowIntent', 'intent', intent)
            const localVarPath = `/v1/flow/{uid}/{intent}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"intent"}}`, encodeURIComponent(String(intent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (userIdentifier !== undefined) {
                localVarQueryParameter['userIdentifier'] = userIdentifier;
            }

            if (groupIdentifier !== undefined) {
                localVarQueryParameter['groupIdentifier'] = groupIdentifier;
            }

            if (includeBlock !== undefined) {
                localVarQueryParameter['include[block]'] = includeBlock;
            }

            if (includeBlockJourney !== undefined) {
                localVarQueryParameter['include[block][journey]'] = includeBlockJourney;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocks: async (version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getBlocks', 'version', version)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('getBlocks', 'userIdentifier', userIdentifier)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getBlocks', 'uid', uid)
            // verify required parameter 'intent' is not null or undefined
            assertParamExists('getBlocks', 'intent', intent)
            const localVarPath = `/v1/block/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"intent"}}`, encodeURIComponent(String(intent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (userIdentifier !== undefined) {
                localVarQueryParameter['userIdentifier'] = userIdentifier;
            }

            if (groupIdentifier !== undefined) {
                localVarQueryParameter['groupIdentifier'] = groupIdentifier;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {string} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlow: async (version: number, userIdentifier: string, uid: string, intent: string, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('getFlow', 'version', version)
            // verify required parameter 'userIdentifier' is not null or undefined
            assertParamExists('getFlow', 'userIdentifier', userIdentifier)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getFlow', 'uid', uid)
            // verify required parameter 'intent' is not null or undefined
            assertParamExists('getFlow', 'intent', intent)
            const localVarPath = `/v1/flow/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"intent"}}`, encodeURIComponent(String(intent)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Api-Key", configuration)

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (userIdentifier !== undefined) {
                localVarQueryParameter['userIdentifier'] = userIdentifier;
            }

            if (groupIdentifier !== undefined) {
                localVarQueryParameter['groupIdentifier'] = groupIdentifier;
            }

            if (includeBlock !== undefined) {
                localVarQueryParameter['include[block]'] = includeBlock;
            }

            if (includeBlockJourney !== undefined) {
                localVarQueryParameter['include[block][journey]'] = includeBlockJourney;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIApi - functional programming interface
 * @export
 */
export const APIApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = APIApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} blockUid 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockGoToIntent(version: number, userIdentifier: string, blockUid: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockGoToIntent(version, userIdentifier, blockUid, uid, intent, groupIdentifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockIntent(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockIntent(version, userIdentifier, uid, intent, groupIdentifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {FlowIntentIntentParameter} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flowIntent(version: number, userIdentifier: string, uid: string, intent: FlowIntentIntentParameter, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flowIntent(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlocks(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SerializableBlock>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlocks(version, userIdentifier, uid, intent, groupIdentifier, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {string} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFlow(version: number, userIdentifier: string, uid: string, intent: string, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlowResponseBody>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFlow(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * APIApi - factory interface
 * @export
 */
export const APIApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = APIApiFp(configuration)
    return {
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} blockUid 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockGoToIntent(version: number, userIdentifier: string, blockUid: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: any): AxiosPromise<void> {
            return localVarFp.blockGoToIntent(version, userIdentifier, blockUid, uid, intent, groupIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockIntent(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: any): AxiosPromise<void> {
            return localVarFp.blockIntent(version, userIdentifier, uid, intent, groupIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {FlowIntentIntentParameter} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flowIntent(version: number, userIdentifier: string, uid: string, intent: FlowIntentIntentParameter, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.flowIntent(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {BlockIntent} intent 
         * @param {string} [groupIdentifier] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlocks(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: any): AxiosPromise<SerializableBlock> {
            return localVarFp.getBlocks(version, userIdentifier, uid, intent, groupIdentifier, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} version 
         * @param {string} userIdentifier 
         * @param {string} uid 
         * @param {string} intent 
         * @param {string} [groupIdentifier] 
         * @param {boolean} [includeBlock] 
         * @param {boolean} [includeBlockJourney] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFlow(version: number, userIdentifier: string, uid: string, intent: string, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: any): AxiosPromise<FlowResponseBody> {
            return localVarFp.getFlow(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * APIApi - object-oriented interface
 * @export
 * @class APIApi
 * @extends {BaseAPI}
 */
export class APIApi extends BaseAPI {
    /**
     * 
     * @param {number} version 
     * @param {string} userIdentifier 
     * @param {string} blockUid 
     * @param {string} uid 
     * @param {BlockIntent} intent 
     * @param {string} [groupIdentifier] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public blockGoToIntent(version: number, userIdentifier: string, blockUid: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).blockGoToIntent(version, userIdentifier, blockUid, uid, intent, groupIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} version 
     * @param {string} userIdentifier 
     * @param {string} uid 
     * @param {BlockIntent} intent 
     * @param {string} [groupIdentifier] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public blockIntent(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).blockIntent(version, userIdentifier, uid, intent, groupIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} version 
     * @param {string} userIdentifier 
     * @param {string} uid 
     * @param {FlowIntentIntentParameter} intent 
     * @param {string} [groupIdentifier] 
     * @param {boolean} [includeBlock] 
     * @param {boolean} [includeBlockJourney] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public flowIntent(version: number, userIdentifier: string, uid: string, intent: FlowIntentIntentParameter, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).flowIntent(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} version 
     * @param {string} userIdentifier 
     * @param {string} uid 
     * @param {BlockIntent} intent 
     * @param {string} [groupIdentifier] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getBlocks(version: number, userIdentifier: string, uid: string, intent: BlockIntent, groupIdentifier?: string, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).getBlocks(version, userIdentifier, uid, intent, groupIdentifier, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} version 
     * @param {string} userIdentifier 
     * @param {string} uid 
     * @param {string} intent 
     * @param {string} [groupIdentifier] 
     * @param {boolean} [includeBlock] 
     * @param {boolean} [includeBlockJourney] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIApi
     */
    public getFlow(version: number, userIdentifier: string, uid: string, intent: string, groupIdentifier?: string, includeBlock?: boolean, includeBlockJourney?: boolean, options?: AxiosRequestConfig) {
        return APIApiFp(this.configuration).getFlow(version, userIdentifier, uid, intent, groupIdentifier, includeBlock, includeBlockJourney, options).then((request) => request(this.axios, this.basePath));
    }
}


